import { chatAIML, imageAIML, getCacheAIML } from 'backend/aiml.web.js';
import { v4 as uuidv4 } from 'uuid';

// available AIs
const LLMs = [ 'OpenAI', 'Mistral', 'DeepSeek', 'Llama', 'Grok', 'Gemini', 'Cohere'];

// background colors for each speaker (generated by AI)
const speakerColors = {
    OpenAI: '#10A37F',   // Teal green - innovation & reliability
    Mistral: '#FF6B00',  // Vibrant orange - energy & creativity (Mistral's vibe)
    DeepSeek: '#003366', // Deep navy - precision and depth (like deep waters)
    Llama: '#87CEEB',    // Light blue - curiosity & storytelling (like clear skies)
    Grok: '#2F4F4F',     // Dark slate gray - mischievous & bold
    Gemini: '#1E90FF',   // Dodger blue - Google Bard's adaptive creativity
    Cohere: '#800080',   // Purple - enterprise focus & reliable infrastructure
    default: '#F0F0F0'
};

/////////////////////////////////////////////
//
// Core improv theater flow
//
/////////////////////////////////////////////

export async function runImprovTheater(inspiration) {
    let conversationLog = "";

	const createImages = $w("#checkboxImages").checked;
	const director = slotsFilled[0];
	const player1 = slotsFilled[1];
	const player2 = slotsFilled[2];
	const audience = slotsFilled[3];

    // Step 1: Generate the setting
    const setting = await generateSetting(director, inspiration);
	$w("#textLocation").text = "Location:\n" + setting;

    // Step 2: Generate characters based on the setting
	if (createImages) $w("#hourglass1").show();
    const char1 = await generateCharacter(player1, setting);
	// addMessageToChat (player1, char1);
	if (createImages) generateImageAIML("dall-e-2", "Avatar on stage for: " + char1, 1);

	if (createImages) $w("#hourglass2").show();
	const char2 = await generateCharacter(player2, setting);
	// addMessageToChat (player2, char2);
	if (createImages) generateImageAIML("dall-e-2", "Avatar on stage for: " + char2, 2);

    // Step 3: Simulate conversation
    let turns = 3;
    while (turns >= 0) {  // Limit turns
        const response1 = await getCharacterResponse(player1, setting, char1, conversationLog);
        conversationLog += `\n${player1}: ${response1}`;
		const emoji1 = await emojiResponse(audience, response1);
		addMessageToChatAdvanced (player1, response1, emoji1)

		let response2;
		if (turns == 0)
		    response2 = await getCharacterFinalResponse(player2, setting, char2, conversationLog);
		else
        	response2 = await getCharacterResponse(player2, setting, char2, conversationLog);
        conversationLog += `\n${player2}: ${response2}`;
		const emoji2 = await emojiResponse(audience, response2);
		addMessageToChatAdvanced (player2, response2, emoji2)

/*
        // Step 4: director monitors conversation
        const rating = await evaluateConversation(director, setting, conversationLog);
		console.log(rating);
        if (+rating < 7) break;
*/
        turns--;
    }

    // Step 5: Generate closing wisdom
    const wisdom = await generateClosingWisdom(director, setting, conversationLog);
	addMessageToChat ("Conclusion", wisdom, "playEval")

}

let creativity = 0.7;
let slotsFilled = [null, null, null, null];
let unknownAvatar;
let selectedSlot = 0;

$w.onReady(async function () {

    // some initial bookkeeping stuff
	renderChat();
    $w('#improButton').disable();
	$w("#hourglass1").hide();
	$w("#hourglass2").hide();
	unknownAvatar = $w("#imageChar1").src;
    
    // Assign click events to slots
	for (let i = 1; i <= slotsFilled.length; i++) {
    	$w('#slot' + i).onClick(() => selectSlot(i));
	}
    
    // add click events to all llm icons
	LLMs.forEach(llm => {
		$w("#icon" + llm).onClick(() => selectIcon(llm));
	});

	// default for hackathon
	for (let i = 1; i <= slotsFilled.length; i++) {
		selectSlot(i);selectIcon("DeepSeek");
	}

    $w("#improButton").onClick(async () => {

		$w("#improButton").disable();

		// clean up for this run
		//$w("#playScript").value = "";
		$w("#textLocation").text = "";
		$w("#playEval").value = "";
		$w("#imageChar1").src = unknownAvatar;
		$w("#imageChar2").src = unknownAvatar;
		chatMessages =[];
		renderChat();

		// run impro show based on userinput and creativity (temperature)
		creativity = $w("#slider").value/10;
		const inspiration = $w("#userInput").value;
		await runImprovTheater(inspiration);

		$w("#improButton").enable();

    });

    $w("#diceButton").onClick(async () => {
		setRandomLLMs();
    });

});

//////////////////////////////////////////////////////////////////////////
//
// UI - display chat messages
//
//////////////////////////////////////////////////////////////////////////

function addMessageToChat(sender, message, box = "playScript") {
	$w("#" + box).value += `${sender}: ${message}\n\n`;
	$w("#" + box).focus();
}

// Global array to hold chat messages
let chatMessages = [];

function addMessageToChatAdvanced(sender, message, emoji)
{

        // Add new message and sort newest first
        const newChatEntry = {
			_id: `${Date.now()}-${Math.floor(Math.random() * 10000)}`,
            speaker: sender,
            text: message,
			emoji: emoji,
            timestamp: Date.now()
        };
        chatMessages.push(newChatEntry);
        chatMessages.sort((a, b) => b.timestamp - a.timestamp);

        // Render updated chat
        renderChat();
}

// Function to render chat messages
function renderChat() {
    $w('#chatRepeater').data = chatMessages;

    $w('#chatRepeater').onItemReady(($item, itemData) => {
        // Set message text and speaker name
        $item('#chatMessageText').text = itemData.text;
        $item('#chatEmoji').text = itemData.emoji;

        // Set background color based on speaker
        const bgColor = speakerColors[itemData.speaker] || speakerColors.default;
        $item('#chatContainerBox').style.backgroundColor = bgColor;
    });
}

//////////////////////////////////////////////////////////////////////////
//
// UI - select LLMs
//
//////////////////////////////////////////////////////////////////////////

function setRandomLLMs() {
    // Shuffle the array and get 4 elements
    const shuffled = LLMs.sort(() => 0.5 - Math.random());
    const selected = shuffled.slice(0, 4);

	// Loop through available slots
	for (let i = 0; i < selected.length; i++) {
		// Slot numbers start at 1, so add 1 to the index
		const slotNumber = i + 1;

		// set slots
		selectSlot(slotNumber);
		selectIcon(selected[i]);
	}

}

function selectSlot(slot) {
	selectedSlot = slot;
}

// Function to handle slot click
function selectIcon(selectedIcon) {
	if (!selectedSlot) {
		return;
	}

	// Set the slot image to the selected icon's image
	const iconSrc = $w("#icon" + selectedIcon).src;
	$w(`#slot${selectedSlot}Image`).src = iconSrc;

	// Update slot status
	slotsFilled[selectedSlot-1] = selectedIcon;

	// Reset selected icon
	selectedSlot = 0;

	// Check if all slots are filled
	if (slotsFilled.every((slot) => slot )) {
		$w('#improButton').enable();
	}
}


///////////////////////////////////////////////////////////////////////
//
// Prompts and code
//
///////////////////////////////////////////////////////////////////////

// CACHE _ init
let poll = [];

// CACHE - call
async function generateImageAIML(model, prompt, destination)
{
	const requestId = uuidv4();

	try {
		const response = await imageAIML(requestId, model, prompt);
		finishImage(destination, response.data.data[0].url)
	} catch (error) {
		console.log("Image creation " + destination + " timed out...");
		poll[destination] = setInterval(async () => {
			const response = await getCacheAIML(requestId);
			if (response.status === 'complete') {
				finishImage(destination, response.data.data[0].url)
			} else if (response.status === "expired") {
				finishImage(destination, null);
			}
		}, 3*1000);
	}
}

// CACHE - poller
function finishImage(destination, url)
{
	if (url) $w("#imageChar" + destination).src = url;
	$w("#hourglass" + destination).hide();

    // stop polling
    if (poll[destination]) clearInterval(poll[destination]);
    poll[destination] = null;
}

// chat AI/ML
async function _callAI(model, prompt)
{
	const systemModels = {
		OpenAI: "gpt-4o",
		DeepSeek: "deepseek-ai/deepseek-llm-67b-chat",
		Mistral: "mistralai/Mistral-7B-Instruct-v0.3",
		Llama: "meta-llama/Llama-3-8b-chat-hf",
		Gemini: "gemini-2.0-flash-exp",
		Grok: "x-ai/grok-beta",
		Cohere: "cohere/command-r-plus"
	};

	const response = await chatAIML(systemModels[model],  [{ role: 'user', content: prompt }], creativity);

	if (!response.choices) return "error....";

	return response.choices[0].message.content
}

// Step 1: Generate setting and challenge
export async function generateSetting(model, inspiration) {
    const prompt = `Give a unique one line description for a location. Inspired by ${inspiration}.`;
    return await _callAI(model, prompt);
}

// Step 2: Generate character based on the setting
export async function generateCharacter(model, setting) {
    const prompt = `Create a one line unique character description with name and personality that fits the following setting: ${setting}.`;
    return await _callAI(model, prompt);
}

// Step 3a: Generate conversational response based on character description and conversation context
export async function getCharacterResponse(model, setting, character, context) {
    const prompt = `You are ${character} in ${setting}. The conversation so far: "${context}". Respond with a next authentic line for your character.`;
    return await _callAI(model, prompt);
}

// Step 3b: Generate conversational response based on character description and conversation context
export async function getCharacterFinalResponse(model, setting, character, context) {
    const prompt = `You are ${character} in ${setting}. The conversation so far: "${context}". Respond with the final line for your character.`;
    return await _callAI(model, prompt);
}

// Step 4a: Evaluate conversation to decide whether it should continue
export async function evaluateConversation(model, setting, conversation) {
    const prompt = `Rate the improv theater conversation for creativity and potential on a scale 1 to 10. Only return the rating number. Conversation: "${conversation}"`;
    const result = await _callAI(model, prompt);
    return result.trim().toUpperCase();
}

// Step 4b: Generate emoji to response
export async function emojiResponse(model, response) {
    const prompt = `Create an human emotive emoji in reaction to: ${response}`;
    const result = await _callAI(model, prompt);
    return _getFirstEmoji(result);		// shorten to be sure
}

// Step 5: Generate closing wisdom related to the setting and conversation
export async function generateClosingWisdom(model, setting, conversation) {
    const prompt = `An improv theater scene set in ${setting}. Rate the performance the scene on a scale from 1 to 10. End with a lighthearted yet deep slogan related to the play. The scene: "${conversation}".`;
    return await _callAI(model, prompt);
}

function _getFirstEmoji(str) {
    const chars = Array.from(str);
    return chars.find(char => /\p{Emoji}/u.test(char)) || "";
}